<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Microbit-V2: codal::Serial Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Microbit-V2<span id="projectnumber">&#160;1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classcodal_1_1_serial.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classcodal_1_1_serial-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">codal::Serial Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_serial_8h_source.html">Serial.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for codal::Serial:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classcodal_1_1_serial.png" usemap="#codal::Serial_map" alt=""/>
  <map id="codal::Serial_map" name="codal::Serial_map">
<area href="classcodal_1_1_codal_component.html" alt="codal::CodalComponent" shape="rect" coords="0,0,145,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa7b46c00d4c1420b1bdcd6240728eb25"><td class="memItemLeft" align="right" valign="top"><a id="aa7b46c00d4c1420b1bdcd6240728eb25" name="aa7b46c00d4c1420b1bdcd6240728eb25"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>dataTransmitted</b> ()</td></tr>
<tr class="separator:aa7b46c00d4c1420b1bdcd6240728eb25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac87a108d7ec92e878e3536e4d1ee6e98"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcodal_1_1_serial.html#ac87a108d7ec92e878e3536e4d1ee6e98">dataReceived</a> (char c)</td></tr>
<tr class="separator:ac87a108d7ec92e878e3536e4d1ee6e98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dacc585b3a25af82e3c701de51c3d79"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcodal_1_1_serial.html#a9dacc585b3a25af82e3c701de51c3d79">idleCallback</a> () override</td></tr>
<tr class="separator:a9dacc585b3a25af82e3c701de51c3d79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb24acb729f10f75cb6e201f16c86c8e"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcodal_1_1_serial.html#aeb24acb729f10f75cb6e201f16c86c8e">putc</a> (char c)=0</td></tr>
<tr class="separator:aeb24acb729f10f75cb6e201f16c86c8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af955777314d04fe61d1af1de238e7593"><td class="memItemLeft" align="right" valign="top"><a id="af955777314d04fe61d1af1de238e7593" name="af955777314d04fe61d1af1de238e7593"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>getc</b> ()=0</td></tr>
<tr class="separator:af955777314d04fe61d1af1de238e7593"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05ee0ad9561b06c78d290b484a5ab696"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcodal_1_1_serial.html#a05ee0ad9561b06c78d290b484a5ab696">Serial</a> (<a class="el" href="classcodal_1_1_pin.html">Pin</a> &amp;tx, <a class="el" href="classcodal_1_1_pin.html">Pin</a> &amp;rx, uint8_t rxBufferSize=CODAL_SERIAL_DEFAULT_BUFFER_SIZE, uint8_t txBufferSize=CODAL_SERIAL_DEFAULT_BUFFER_SIZE, uint16_t id=DEVICE_ID_SERIAL)</td></tr>
<tr class="separator:a05ee0ad9561b06c78d290b484a5ab696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e6939e1a93062bf0ae695a61a630fad"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcodal_1_1_serial.html#a0e6939e1a93062bf0ae695a61a630fad">sendChar</a> (char c, SerialMode mode=DEVICE_DEFAULT_SERIAL_MODE)</td></tr>
<tr class="separator:a0e6939e1a93062bf0ae695a61a630fad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a5f11ee25b5f74f1585bb665a077860"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcodal_1_1_serial.html#a2a5f11ee25b5f74f1585bb665a077860">send</a> (<a class="el" href="classcodal_1_1_managed_string.html">ManagedString</a> s, SerialMode mode=DEVICE_DEFAULT_SERIAL_MODE)</td></tr>
<tr class="separator:a2a5f11ee25b5f74f1585bb665a077860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4e3dd55fb0ee1237a760c3bdb8ed89c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcodal_1_1_serial.html#aa4e3dd55fb0ee1237a760c3bdb8ed89c">send</a> (uint8_t *buffer, int bufferLen, SerialMode mode=DEVICE_DEFAULT_SERIAL_MODE)</td></tr>
<tr class="separator:aa4e3dd55fb0ee1237a760c3bdb8ed89c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af926923fdece1d7f4c97d9a4ba3f9586"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcodal_1_1_serial.html#af926923fdece1d7f4c97d9a4ba3f9586">read</a> (SerialMode mode=DEVICE_DEFAULT_SERIAL_MODE)</td></tr>
<tr class="separator:af926923fdece1d7f4c97d9a4ba3f9586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87cc6101c0fd5fa14e2cb37b666f214e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcodal_1_1_serial.html#a87cc6101c0fd5fa14e2cb37b666f214e">getChar</a> (SerialMode mode)</td></tr>
<tr class="separator:a87cc6101c0fd5fa14e2cb37b666f214e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef0c7ac915d0033a140d5afac4b584ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcodal_1_1_managed_string.html">ManagedString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcodal_1_1_serial.html#aef0c7ac915d0033a140d5afac4b584ad">read</a> (int size, SerialMode mode=DEVICE_DEFAULT_SERIAL_MODE)</td></tr>
<tr class="separator:aef0c7ac915d0033a140d5afac4b584ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81ff3a381aa6d838cc975c2520acb4b1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcodal_1_1_serial.html#a81ff3a381aa6d838cc975c2520acb4b1">read</a> (uint8_t *buffer, int bufferLen, SerialMode mode=DEVICE_DEFAULT_SERIAL_MODE)</td></tr>
<tr class="separator:a81ff3a381aa6d838cc975c2520acb4b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab164675b09d4202bd7d73c11d1ac45d6"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcodal_1_1_managed_string.html">ManagedString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcodal_1_1_serial.html#ab164675b09d4202bd7d73c11d1ac45d6">readUntil</a> (<a class="el" href="classcodal_1_1_managed_string.html">ManagedString</a> delimeters, SerialMode mode=DEVICE_DEFAULT_SERIAL_MODE)</td></tr>
<tr class="separator:ab164675b09d4202bd7d73c11d1ac45d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10bd53e8a33492fd80f9e58b8889ebfc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcodal_1_1_serial.html#a10bd53e8a33492fd80f9e58b8889ebfc">setBaud</a> (int baudrate)</td></tr>
<tr class="separator:a10bd53e8a33492fd80f9e58b8889ebfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a395667dae79c223d62adf70fbb175f4c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcodal_1_1_serial.html#a395667dae79c223d62adf70fbb175f4c">redirect</a> (<a class="el" href="classcodal_1_1_pin.html">Pin</a> &amp;tx, <a class="el" href="classcodal_1_1_pin.html">Pin</a> &amp;rx)</td></tr>
<tr class="separator:a395667dae79c223d62adf70fbb175f4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c2f131c0d55c4d56057bbd9fea00a32"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcodal_1_1_serial.html#a3c2f131c0d55c4d56057bbd9fea00a32">eventAfter</a> (int len, SerialMode mode=ASYNC)</td></tr>
<tr class="separator:a3c2f131c0d55c4d56057bbd9fea00a32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8587ee9d776a015293a0e22eea17328c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcodal_1_1_serial.html#a8587ee9d776a015293a0e22eea17328c">eventOn</a> (<a class="el" href="classcodal_1_1_managed_string.html">ManagedString</a> delimeters, SerialMode mode=ASYNC)</td></tr>
<tr class="separator:a8587ee9d776a015293a0e22eea17328c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5419572191df40c29ff312623adb7f7f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcodal_1_1_serial.html#a5419572191df40c29ff312623adb7f7f">isReadable</a> ()</td></tr>
<tr class="separator:a5419572191df40c29ff312623adb7f7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38120bef500231fc0d1c35c096480206"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcodal_1_1_serial.html#a38120bef500231fc0d1c35c096480206">isWriteable</a> ()</td></tr>
<tr class="separator:a38120bef500231fc0d1c35c096480206"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7fb939952a2021fc7144b2c7eea0674"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcodal_1_1_serial.html#ad7fb939952a2021fc7144b2c7eea0674">setRxBufferSize</a> (uint8_t size)</td></tr>
<tr class="separator:ad7fb939952a2021fc7144b2c7eea0674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcf69b11c57d4a0c88f7b9486f3b3f01"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcodal_1_1_serial.html#adcf69b11c57d4a0c88f7b9486f3b3f01">setTxBufferSize</a> (uint8_t size)</td></tr>
<tr class="separator:adcf69b11c57d4a0c88f7b9486f3b3f01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3602204cffd7992a85fb1564cbbe9e35"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcodal_1_1_serial.html#a3602204cffd7992a85fb1564cbbe9e35">getRxBufferSize</a> ()</td></tr>
<tr class="separator:a3602204cffd7992a85fb1564cbbe9e35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e393fde4d19ef2ec8f65db8a8b8b230"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcodal_1_1_serial.html#a4e393fde4d19ef2ec8f65db8a8b8b230">getTxBufferSize</a> ()</td></tr>
<tr class="separator:a4e393fde4d19ef2ec8f65db8a8b8b230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dd906d92cf929c6ac6dff1f88f5c891"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcodal_1_1_serial.html#a2dd906d92cf929c6ac6dff1f88f5c891">clearRxBuffer</a> ()</td></tr>
<tr class="separator:a2dd906d92cf929c6ac6dff1f88f5c891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba1f61f3bee51684a3bcfcbe52b030b4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcodal_1_1_serial.html#aba1f61f3bee51684a3bcfcbe52b030b4">clearTxBuffer</a> ()</td></tr>
<tr class="separator:aba1f61f3bee51684a3bcfcbe52b030b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2453e9d4752e90313032f8777042d044"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcodal_1_1_serial.html#a2453e9d4752e90313032f8777042d044">rxBufferedSize</a> ()</td></tr>
<tr class="separator:a2453e9d4752e90313032f8777042d044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30622ea7b68857a4704998cf9acc1f6b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcodal_1_1_serial.html#a30622ea7b68857a4704998cf9acc1f6b">txBufferedSize</a> ()</td></tr>
<tr class="separator:a30622ea7b68857a4704998cf9acc1f6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab96eb0e1638ffa0189a4f3241bc747e6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcodal_1_1_serial.html#ab96eb0e1638ffa0189a4f3241bc747e6">rxInUse</a> ()</td></tr>
<tr class="separator:ab96eb0e1638ffa0189a4f3241bc747e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14bbd54b2e5b986b7bc3b14a830833c3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcodal_1_1_serial.html#a14bbd54b2e5b986b7bc3b14a830833c3">txInUse</a> ()</td></tr>
<tr class="separator:a14bbd54b2e5b986b7bc3b14a830833c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64c5b83c82f37e4b287f8630685185d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcodal_1_1_serial.html#a64c5b83c82f37e4b287f8630685185d7">lockRx</a> ()</td></tr>
<tr class="separator:a64c5b83c82f37e4b287f8630685185d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad89cef8d8e137df558692f126baf9d21"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcodal_1_1_serial.html#ad89cef8d8e137df558692f126baf9d21">lockTx</a> ()</td></tr>
<tr class="separator:ad89cef8d8e137df558692f126baf9d21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5278b596bb36574bc2a7f2c69965e7d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcodal_1_1_serial.html#a5278b596bb36574bc2a7f2c69965e7d0">unlockRx</a> ()</td></tr>
<tr class="separator:a5278b596bb36574bc2a7f2c69965e7d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d94f3b0d677105de4a3adc332c91f67"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcodal_1_1_serial.html#a1d94f3b0d677105de4a3adc332c91f67">unlockTx</a> ()</td></tr>
<tr class="separator:a1d94f3b0d677105de4a3adc332c91f67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classcodal_1_1_codal_component"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classcodal_1_1_codal_component')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classcodal_1_1_codal_component.html">codal::CodalComponent</a></td></tr>
<tr class="memitem:a13e3af6bd42728b50b41c96aa246b8a8 inherit pub_methods_classcodal_1_1_codal_component"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcodal_1_1_codal_component.html#a13e3af6bd42728b50b41c96aa246b8a8">addComponent</a> ()</td></tr>
<tr class="separator:a13e3af6bd42728b50b41c96aa246b8a8 inherit pub_methods_classcodal_1_1_codal_component"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32789682f5218ddcf98f9dca834d102d inherit pub_methods_classcodal_1_1_codal_component"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcodal_1_1_codal_component.html#a32789682f5218ddcf98f9dca834d102d">removeComponent</a> ()</td></tr>
<tr class="separator:a32789682f5218ddcf98f9dca834d102d inherit pub_methods_classcodal_1_1_codal_component"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ba4e1ff99531da909283abc45dacf40 inherit pub_methods_classcodal_1_1_codal_component"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcodal_1_1_codal_component.html#a6ba4e1ff99531da909283abc45dacf40">CodalComponent</a> ()</td></tr>
<tr class="separator:a6ba4e1ff99531da909283abc45dacf40 inherit pub_methods_classcodal_1_1_codal_component"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6453194acfc6f6bff64c04d657de41b3 inherit pub_methods_classcodal_1_1_codal_component"><td class="memItemLeft" align="right" valign="top"><a id="a6453194acfc6f6bff64c04d657de41b3" name="a6453194acfc6f6bff64c04d657de41b3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CodalComponent</b> (uint16_t id, uint16_t status)</td></tr>
<tr class="separator:a6453194acfc6f6bff64c04d657de41b3 inherit pub_methods_classcodal_1_1_codal_component"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabce36418573fa49800cdbcdfc63e056 inherit pub_methods_classcodal_1_1_codal_component"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcodal_1_1_codal_component.html#aabce36418573fa49800cdbcdfc63e056">init</a> ()</td></tr>
<tr class="separator:aabce36418573fa49800cdbcdfc63e056 inherit pub_methods_classcodal_1_1_codal_component"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0be29d29ebe2e95ab2784b438fa5c663 inherit pub_methods_classcodal_1_1_codal_component"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcodal_1_1_codal_component.html#a0be29d29ebe2e95ab2784b438fa5c663">periodicCallback</a> ()</td></tr>
<tr class="separator:a0be29d29ebe2e95ab2784b438fa5c663 inherit pub_methods_classcodal_1_1_codal_component"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37dab3cb4347533746d0e4f557e8feb5 inherit pub_methods_classcodal_1_1_codal_component"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcodal_1_1_codal_component.html#a37dab3cb4347533746d0e4f557e8feb5">idleCallback</a> ()</td></tr>
<tr class="separator:a37dab3cb4347533746d0e4f557e8feb5 inherit pub_methods_classcodal_1_1_codal_component"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b23a42b7cb0cbb4c102b5b8bc5dcfde inherit pub_methods_classcodal_1_1_codal_component"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcodal_1_1_codal_component.html#a4b23a42b7cb0cbb4c102b5b8bc5dcfde">setSleep</a> (bool doSleep)</td></tr>
<tr class="separator:a4b23a42b7cb0cbb4c102b5b8bc5dcfde inherit pub_methods_classcodal_1_1_codal_component"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63e8fd6ff3cb573c4567267acd5ecefe inherit pub_methods_classcodal_1_1_codal_component"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcodal_1_1_codal_component.html#a63e8fd6ff3cb573c4567267acd5ecefe">deepSleepCallback</a> (deepSleepCallbackReason reason, <a class="el" href="structcodal_1_1_codal_component_1_1deep_sleep_callback_data.html">deepSleepCallbackData</a> *data)</td></tr>
<tr class="separator:a63e8fd6ff3cb573c4567267acd5ecefe inherit pub_methods_classcodal_1_1_codal_component"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6bdcbcf3859f35746d612fbfb156991 inherit pub_methods_classcodal_1_1_codal_component"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcodal_1_1_codal_component.html#ad6bdcbcf3859f35746d612fbfb156991">~CodalComponent</a> ()</td></tr>
<tr class="separator:ad6bdcbcf3859f35746d612fbfb156991 inherit pub_methods_classcodal_1_1_codal_component"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a13a792439893dcf4be453e7d00c6bff4"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcodal_1_1_serial.html#a13a792439893dcf4be453e7d00c6bff4">enableInterrupt</a> (SerialInterruptType t)=0</td></tr>
<tr class="separator:a13a792439893dcf4be453e7d00c6bff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fadc488cdd5a70eecb912d5631bf185"><td class="memItemLeft" align="right" valign="top"><a id="a9fadc488cdd5a70eecb912d5631bf185" name="a9fadc488cdd5a70eecb912d5631bf185"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>disableInterrupt</b> (SerialInterruptType t)=0</td></tr>
<tr class="separator:a9fadc488cdd5a70eecb912d5631bf185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62feb74129b71d086b7a452a29a3e6f3"><td class="memItemLeft" align="right" valign="top"><a id="a62feb74129b71d086b7a452a29a3e6f3" name="a62feb74129b71d086b7a452a29a3e6f3"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>setBaudrate</b> (uint32_t baudrate)=0</td></tr>
<tr class="separator:a62feb74129b71d086b7a452a29a3e6f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6d04e075724b7ff8b4df02278d11286"><td class="memItemLeft" align="right" valign="top"><a id="aa6d04e075724b7ff8b4df02278d11286" name="aa6d04e075724b7ff8b4df02278d11286"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>configurePins</b> (<a class="el" href="classcodal_1_1_pin.html">Pin</a> &amp;tx, <a class="el" href="classcodal_1_1_pin.html">Pin</a> &amp;rx)=0</td></tr>
<tr class="separator:aa6d04e075724b7ff8b4df02278d11286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1101d6c554227bcbe9dafbe0910830e0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcodal_1_1_serial.html#a1101d6c554227bcbe9dafbe0910830e0">initialiseRx</a> ()</td></tr>
<tr class="separator:a1101d6c554227bcbe9dafbe0910830e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1f53e340ed1ea123af4adfe3880b9bc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcodal_1_1_serial.html#ab1f53e340ed1ea123af4adfe3880b9bc">initialiseTx</a> ()</td></tr>
<tr class="separator:ab1f53e340ed1ea123af4adfe3880b9bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad465ae90e2501c2853b35809a490fd0b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcodal_1_1_serial.html#ad465ae90e2501c2853b35809a490fd0b">circularCopy</a> (uint8_t *circularBuff, uint8_t circularBuffSize, uint8_t *linearBuff, uint16_t tailPosition, uint16_t headPosition)</td></tr>
<tr class="separator:ad465ae90e2501c2853b35809a490fd0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86de5a38a9a26a5af45cb0dcac8686c3"><td class="memItemLeft" align="right" valign="top"><a id="a86de5a38a9a26a5af45cb0dcac8686c3" name="a86de5a38a9a26a5af45cb0dcac8686c3"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>setTxInterrupt</b> (uint8_t *string, int len, SerialMode mode)</td></tr>
<tr class="separator:a86de5a38a9a26a5af45cb0dcac8686c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a4b1144f9c255593de5cda044c5c861f9"><td class="memItemLeft" align="right" valign="top"><a id="a4b1144f9c255593de5cda044c5c861f9" name="a4b1144f9c255593de5cda044c5c861f9"></a>
<a class="el" href="classcodal_1_1_pin.html">Pin</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>tx</b></td></tr>
<tr class="separator:a4b1144f9c255593de5cda044c5c861f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba3c3be7aa899d6b8e11919a97d06a5a"><td class="memItemLeft" align="right" valign="top"><a id="aba3c3be7aa899d6b8e11919a97d06a5a" name="aba3c3be7aa899d6b8e11919a97d06a5a"></a>
<a class="el" href="classcodal_1_1_pin.html">Pin</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>rx</b></td></tr>
<tr class="separator:aba3c3be7aa899d6b8e11919a97d06a5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab63492e9e31023533d2d09a2eae8e079"><td class="memItemLeft" align="right" valign="top"><a id="ab63492e9e31023533d2d09a2eae8e079" name="ab63492e9e31023533d2d09a2eae8e079"></a>
<a class="el" href="classcodal_1_1_managed_string.html">ManagedString</a>&#160;</td><td class="memItemRight" valign="bottom"><b>delimeters</b></td></tr>
<tr class="separator:ab63492e9e31023533d2d09a2eae8e079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5fe161fa0ae3efce8ec75a91576ef4d"><td class="memItemLeft" align="right" valign="top"><a id="af5fe161fa0ae3efce8ec75a91576ef4d" name="af5fe161fa0ae3efce8ec75a91576ef4d"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>rxBuffHeadMatch</b></td></tr>
<tr class="separator:af5fe161fa0ae3efce8ec75a91576ef4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39798cdc55a781c6c314c0f6391e525c"><td class="memItemLeft" align="right" valign="top"><a id="a39798cdc55a781c6c314c0f6391e525c" name="a39798cdc55a781c6c314c0f6391e525c"></a>
uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><b>rxBuff</b></td></tr>
<tr class="separator:a39798cdc55a781c6c314c0f6391e525c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a83e47734d3c45ee34cae3896c7064a"><td class="memItemLeft" align="right" valign="top"><a id="a8a83e47734d3c45ee34cae3896c7064a" name="a8a83e47734d3c45ee34cae3896c7064a"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>rxBuffSize</b></td></tr>
<tr class="separator:a8a83e47734d3c45ee34cae3896c7064a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8517754c2bb62a2f669a33496489f96"><td class="memItemLeft" align="right" valign="top"><a id="aa8517754c2bb62a2f669a33496489f96" name="aa8517754c2bb62a2f669a33496489f96"></a>
volatile uint16_t&#160;</td><td class="memItemRight" valign="bottom"><b>rxBuffHead</b></td></tr>
<tr class="separator:aa8517754c2bb62a2f669a33496489f96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42f5456d815e6e44214dc028fb00908b"><td class="memItemLeft" align="right" valign="top"><a id="a42f5456d815e6e44214dc028fb00908b" name="a42f5456d815e6e44214dc028fb00908b"></a>
uint16_t&#160;</td><td class="memItemRight" valign="bottom"><b>rxBuffTail</b></td></tr>
<tr class="separator:a42f5456d815e6e44214dc028fb00908b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a626c1d0cd7e39d1a7ef3d0c7488e82a8"><td class="memItemLeft" align="right" valign="top"><a id="a626c1d0cd7e39d1a7ef3d0c7488e82a8" name="a626c1d0cd7e39d1a7ef3d0c7488e82a8"></a>
uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><b>txBuff</b></td></tr>
<tr class="separator:a626c1d0cd7e39d1a7ef3d0c7488e82a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08662b7a0983c88be8457b8a1961fdb9"><td class="memItemLeft" align="right" valign="top"><a id="a08662b7a0983c88be8457b8a1961fdb9" name="a08662b7a0983c88be8457b8a1961fdb9"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>txBuffSize</b></td></tr>
<tr class="separator:a08662b7a0983c88be8457b8a1961fdb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a5cd4703144d90c8f011cad8fc0291e"><td class="memItemLeft" align="right" valign="top"><a id="a8a5cd4703144d90c8f011cad8fc0291e" name="a8a5cd4703144d90c8f011cad8fc0291e"></a>
uint16_t&#160;</td><td class="memItemRight" valign="bottom"><b>txBuffHead</b></td></tr>
<tr class="separator:a8a5cd4703144d90c8f011cad8fc0291e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f9fb91a310aedc33971723c336b9a08"><td class="memItemLeft" align="right" valign="top"><a id="a6f9fb91a310aedc33971723c336b9a08" name="a6f9fb91a310aedc33971723c336b9a08"></a>
volatile uint16_t&#160;</td><td class="memItemRight" valign="bottom"><b>txBuffTail</b></td></tr>
<tr class="separator:a6f9fb91a310aedc33971723c336b9a08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab60976b9254dd4ccf7e2425b96d8c13b"><td class="memItemLeft" align="right" valign="top"><a id="ab60976b9254dd4ccf7e2425b96d8c13b" name="ab60976b9254dd4ccf7e2425b96d8c13b"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>baudrate</b></td></tr>
<tr class="separator:ab60976b9254dd4ccf7e2425b96d8c13b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classcodal_1_1_codal_component"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classcodal_1_1_codal_component')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classcodal_1_1_codal_component.html">codal::CodalComponent</a></td></tr>
<tr class="memitem:a6dcf2a07948ff43d09ac17a5c5758a6e inherit pub_types_classcodal_1_1_codal_component"><td class="memItemLeft" align="right" valign="top"><a id="a6dcf2a07948ff43d09ac17a5c5758a6e" name="a6dcf2a07948ff43d09ac17a5c5758a6e"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>deepSleepCallbackReason</b> { <br />
&#160;&#160;<b>deepSleepCallbackPrepare</b>
, <b>deepSleepCallbackBegin</b>
, <b>deepSleepCallbackBeginWithWakeUps</b>
, <b>deepSleepCallbackEnd</b>
, <br />
&#160;&#160;<b>deepSleepCallbackEndWithWakeUps</b>
, <b>deepSleepCallbackCountWakeUps</b>
, <b>deepSleepCallbackClearWakeUps</b>
<br />
 }</td></tr>
<tr class="separator:a6dcf2a07948ff43d09ac17a5c5758a6e inherit pub_types_classcodal_1_1_codal_component"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46da4adc6fe4ab79bcc747ed015e3107 inherit pub_types_classcodal_1_1_codal_component"><td class="memItemLeft" align="right" valign="top"><a id="a46da4adc6fe4ab79bcc747ed015e3107" name="a46da4adc6fe4ab79bcc747ed015e3107"></a>
typedef enum codal::CodalComponent::deepSleepCallbackReason&#160;</td><td class="memItemRight" valign="bottom"><b>deepSleepCallbackReason</b></td></tr>
<tr class="separator:a46da4adc6fe4ab79bcc747ed015e3107 inherit pub_types_classcodal_1_1_codal_component"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83d4670c5423af6e5dea7f462d9ffc96 inherit pub_types_classcodal_1_1_codal_component"><td class="memItemLeft" align="right" valign="top"><a id="a83d4670c5423af6e5dea7f462d9ffc96" name="a83d4670c5423af6e5dea7f462d9ffc96"></a>
typedef struct <a class="el" href="structcodal_1_1_codal_component_1_1deep_sleep_callback_data.html">codal::CodalComponent::deepSleepCallbackData</a>&#160;</td><td class="memItemRight" valign="bottom"><b>deepSleepCallbackData</b></td></tr>
<tr class="separator:a83d4670c5423af6e5dea7f462d9ffc96 inherit pub_types_classcodal_1_1_codal_component"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classcodal_1_1_codal_component"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classcodal_1_1_codal_component')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classcodal_1_1_codal_component.html">codal::CodalComponent</a></td></tr>
<tr class="memitem:ad56c7f0b00a32fe011e3155893ae6401 inherit pub_static_methods_classcodal_1_1_codal_component"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcodal_1_1_codal_component.html#ad56c7f0b00a32fe011e3155893ae6401">setAllSleep</a> (bool doSleep)</td></tr>
<tr class="separator:ad56c7f0b00a32fe011e3155893ae6401 inherit pub_static_methods_classcodal_1_1_codal_component"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74a9f0c80b9bbe89352a544744174a97 inherit pub_static_methods_classcodal_1_1_codal_component"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcodal_1_1_codal_component.html#a74a9f0c80b9bbe89352a544744174a97">deepSleepAll</a> (deepSleepCallbackReason reason, <a class="el" href="structcodal_1_1_codal_component_1_1deep_sleep_callback_data.html">deepSleepCallbackData</a> *data)</td></tr>
<tr class="separator:a74a9f0c80b9bbe89352a544744174a97 inherit pub_static_methods_classcodal_1_1_codal_component"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_attribs_classcodal_1_1_codal_component"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_classcodal_1_1_codal_component')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="classcodal_1_1_codal_component.html">codal::CodalComponent</a></td></tr>
<tr class="memitem:a77ebca4e1177a1a7591dcfe5a32e4556 inherit pub_attribs_classcodal_1_1_codal_component"><td class="memItemLeft" align="right" valign="top"><a id="a77ebca4e1177a1a7591dcfe5a32e4556" name="a77ebca4e1177a1a7591dcfe5a32e4556"></a>
uint16_t&#160;</td><td class="memItemRight" valign="bottom"><b>id</b></td></tr>
<tr class="separator:a77ebca4e1177a1a7591dcfe5a32e4556 inherit pub_attribs_classcodal_1_1_codal_component"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae66978a2ce7830e8a50554bbee8722dc inherit pub_attribs_classcodal_1_1_codal_component"><td class="memItemLeft" align="right" valign="top"><a id="ae66978a2ce7830e8a50554bbee8722dc" name="ae66978a2ce7830e8a50554bbee8722dc"></a>
uint16_t&#160;</td><td class="memItemRight" valign="bottom"><b>status</b></td></tr>
<tr class="separator:ae66978a2ce7830e8a50554bbee8722dc inherit pub_attribs_classcodal_1_1_codal_component"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_attribs_classcodal_1_1_codal_component"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_classcodal_1_1_codal_component')"><img src="closed.png" alt="-"/>&#160;Static Public Attributes inherited from <a class="el" href="classcodal_1_1_codal_component.html">codal::CodalComponent</a></td></tr>
<tr class="memitem:a6cf5986195baf6fd37e22c34f617fa28 inherit pub_static_attribs_classcodal_1_1_codal_component"><td class="memItemLeft" align="right" valign="top"><a id="a6cf5986195baf6fd37e22c34f617fa28" name="a6cf5986195baf6fd37e22c34f617fa28"></a>
static <a class="el" href="classcodal_1_1_codal_component.html">CodalComponent</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>components</b> [DEVICE_COMPONENT_COUNT]</td></tr>
<tr class="separator:a6cf5986195baf6fd37e22c34f617fa28 inherit pub_static_attribs_classcodal_1_1_codal_component"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Class definition for DeviceSerial.</p>
<p >Represents an instance of RawSerial which accepts codal device specific data types. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a05ee0ad9561b06c78d290b484a5ab696" name="a05ee0ad9561b06c78d290b484a5ab696"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05ee0ad9561b06c78d290b484a5ab696">&#9670;&nbsp;</a></span>Serial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Serial::Serial </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcodal_1_1_pin.html">Pin</a> &amp;&#160;</td>
          <td class="paramname"><em>tx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcodal_1_1_pin.html">Pin</a> &amp;&#160;</td>
          <td class="paramname"><em>rx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>rxBufferSize</em> = <code>CODAL_SERIAL_DEFAULT_BUFFER_SIZE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>txBufferSize</em> = <code>CODAL_SERIAL_DEFAULT_BUFFER_SIZE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>id</em> = <code>DEVICE_ID_SERIAL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Constructor. Create an instance of DeviceSerial</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tx</td><td>the <a class="el" href="classcodal_1_1_pin.html">Pin</a> to be used for transmission</td></tr>
    <tr><td class="paramname">rx</td><td>the <a class="el" href="classcodal_1_1_pin.html">Pin</a> to be used for receiving data</td></tr>
    <tr><td class="paramname">rxBufferSize</td><td>the size of the buffer to be used for receiving bytes</td></tr>
    <tr><td class="paramname">txBufferSize</td><td>the size of the buffer to be used for transmitting bytes</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line">DeviceSerial serial(USBTX, USBRX);</div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>the default baud rate is 115200. <pre class="fragment">  Buffers aren't allocated until the first send or receive respectively.
</pre></dd></dl>
<p>Constructor. Create an instance of DeviceSerial</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tx</td><td>the <a class="el" href="classcodal_1_1_pin.html">Pin</a> to be used for transmission</td></tr>
    <tr><td class="paramname">rx</td><td>the <a class="el" href="classcodal_1_1_pin.html">Pin</a> to be used for receiving data</td></tr>
    <tr><td class="paramname">rxBufferSize</td><td>the size of the buffer to be used for receiving bytes</td></tr>
    <tr><td class="paramname">txBufferSize</td><td>the size of the buffer to be used for transmitting bytes</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line">DeviceSerial serial(USBTX, USBRX);</div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>the default baud rate is 115200. More API details can be found: -<a href="https://github.com/mbedmicro/mbed/blob/master/libraries/mbed/api/SerialBase.h">https://github.com/mbedmicro/mbed/blob/master/libraries/mbed/api/SerialBase.h</a> -<a href="https://github.com/mbedmicro/mbed/blob/master/libraries/mbed/api/RawSerial.h">https://github.com/mbedmicro/mbed/blob/master/libraries/mbed/api/RawSerial.h</a></dd></dl>
<p>Buffers aren't allocated until the first send or receive respectively. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad465ae90e2501c2853b35809a490fd0b" name="ad465ae90e2501c2853b35809a490fd0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad465ae90e2501c2853b35809a490fd0b">&#9670;&nbsp;</a></span>circularCopy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Serial::circularCopy </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>circularBuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>circularBuffSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>linearBuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>tailPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>headPosition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >An internal method that copies values from a circular buffer to a linear buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">circularBuff</td><td>a pointer to the source circular buffer</td></tr>
    <tr><td class="paramname">circularBuffSize</td><td>the size of the circular buffer</td></tr>
    <tr><td class="paramname">linearBuff</td><td>a pointer to the destination linear buffer</td></tr>
    <tr><td class="paramname">tailPosition</td><td>the tail position in the circular buffer you want to copy from</td></tr>
    <tr><td class="paramname">headPosition</td><td>the head position in the circular buffer you want to copy to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>this method assumes that the linear buffer has the appropriate amount of memory to contain the copy operation </dd></dl>

</div>
</div>
<a id="a2dd906d92cf929c6ac6dff1f88f5c891" name="a2dd906d92cf929c6ac6dff1f88f5c891"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dd906d92cf929c6ac6dff1f88f5c891">&#9670;&nbsp;</a></span>clearRxBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Serial::clearRxBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sets the tail to match the head of our circular buffer for reception, effectively clearing the reception buffer.</p>
<dl class="section return"><dt>Returns</dt><dd>CODAL_SERIAL_IN_USE if another fiber is currently using this instance for reception, otherwise DEVICE_OK. </dd></dl>

</div>
</div>
<a id="aba1f61f3bee51684a3bcfcbe52b030b4" name="aba1f61f3bee51684a3bcfcbe52b030b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba1f61f3bee51684a3bcfcbe52b030b4">&#9670;&nbsp;</a></span>clearTxBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Serial::clearTxBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sets the tail to match the head of our circular buffer for transmission, effectively clearing the transmission buffer.</p>
<dl class="section return"><dt>Returns</dt><dd>CODAL_SERIAL_IN_USE if another fiber is currently using this instance for transmission, otherwise DEVICE_OK. </dd></dl>

</div>
</div>
<a id="ac87a108d7ec92e878e3536e4d1ee6e98" name="ac87a108d7ec92e878e3536e4d1ee6e98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac87a108d7ec92e878e3536e4d1ee6e98">&#9670;&nbsp;</a></span>dataReceived()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Serial::dataReceived </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Remove all rxInUse/txInUse calls, and replace with an event mutex (which will be pretty sexy)</p>
<p >Define what needs to be implemented, I think all it is so far:</p><ul>
<li>tx / rx interrupt enable</li>
<li>pin swap</li>
<li>putc getc</li>
<li>Interrupt that calls datarec / datawritten. </li>
</ul>

</div>
</div>
<a id="a13a792439893dcf4be453e7d00c6bff4" name="a13a792439893dcf4be453e7d00c6bff4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13a792439893dcf4be453e7d00c6bff4">&#9670;&nbsp;</a></span>enableInterrupt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int codal::Serial::enableInterrupt </td>
          <td>(</td>
          <td class="paramtype">SerialInterruptType&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >SUB CLASSES / IMPLEMENTATIONS DEFINE THE FOLLOWING METHODS: </p>

</div>
</div>
<a id="a3c2f131c0d55c4d56057bbd9fea00a32" name="a3c2f131c0d55c4d56057bbd9fea00a32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c2f131c0d55c4d56057bbd9fea00a32">&#9670;&nbsp;</a></span>eventAfter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Serial::eventAfter </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SerialMode&#160;</td>
          <td class="paramname"><em>mode</em> = <code>ASYNC</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Configures an event to be fired after "len" characters.</p>
<p >Will generate an event with the ID: DEVICE_ID_SERIAL and the value CODAL_SERIAL_EVT_HEAD_MATCH.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">len</td><td>the number of characters to wait before triggering the event.</td></tr>
    <tr><td class="paramname">mode</td><td>the selected mode, one of: ASYNC, SYNC_SPINWAIT, SYNC_SLEEP. Each mode gives a different behaviour: <pre class="fragment">ASYNC - Will configure the event and return immediately.

SYNC_SPINWAIT - will return DEVICE_INVALID_PARAMETER

SYNC_SLEEP - Will configure the event and block the current fiber until the
             event is received.
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DEVICE_INVALID_PARAMETER if the mode given is SYNC_SPINWAIT, otherwise DEVICE_OK.</dd></dl>
<p>Configures an event to be fired after "len" characters.</p>
<p >Will generate an event with the ID: this-&gt;id and the value CODAL_SERIAL_EVT_HEAD_MATCH.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">len</td><td>the number of characters to wait before triggering the event.</td></tr>
    <tr><td class="paramname">mode</td><td>the selected mode, one of: ASYNC, SYNC_SPINWAIT, SYNC_SLEEP. Each mode gives a different behaviour: <pre class="fragment">ASYNC - Will configure the event and return immediately.

SYNC_SPINWAIT - will return DEVICE_INVALID_PARAMETER

SYNC_SLEEP - Will configure the event and block the current fiber until the
             event is received.
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DEVICE_INVALID_PARAMETER if the mode given is SYNC_SPINWAIT, otherwise DEVICE_OK. </dd></dl>

</div>
</div>
<a id="a8587ee9d776a015293a0e22eea17328c" name="a8587ee9d776a015293a0e22eea17328c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8587ee9d776a015293a0e22eea17328c">&#9670;&nbsp;</a></span>eventOn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Serial::eventOn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcodal_1_1_managed_string.html">ManagedString</a>&#160;</td>
          <td class="paramname"><em>delimeters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SerialMode&#160;</td>
          <td class="paramname"><em>mode</em> = <code>ASYNC</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Configures an event to be fired on a match with one of the delimeters.</p>
<p >Will generate an event with the ID: DEVICE_ID_SERIAL and the value CODAL_SERIAL_EVT_DELIM_MATCH.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">delimeters</td><td>the characters to match received characters against e.g. <a class="el" href="classcodal_1_1_managed_string.html">ManagedString</a>("\n")</td></tr>
    <tr><td class="paramname">mode</td><td>the selected mode, one of: ASYNC, SYNC_SPINWAIT, SYNC_SLEEP. Each mode gives a different behaviour: <pre class="fragment">ASYNC - Will configure the event and return immediately.

SYNC_SPINWAIT - will return DEVICE_INVALID_PARAMETER

SYNC_SLEEP - Will configure the event and block the current fiber until the
             event is received.
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DEVICE_INVALID_PARAMETER if the mode given is SYNC_SPINWAIT, otherwise DEVICE_OK.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>delimeters are matched on a per byte basis.</dd></dl>
<p>Configures an event to be fired on a match with one of the delimeters.</p>
<p >Will generate an event with the ID: this-&gt;id and the value CODAL_SERIAL_EVT_DELIM_MATCH.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">delimeters</td><td>the characters to match received characters against e.g. <a class="el" href="classcodal_1_1_managed_string.html">ManagedString</a>("\n")</td></tr>
    <tr><td class="paramname">mode</td><td>the selected mode, one of: ASYNC, SYNC_SPINWAIT, SYNC_SLEEP. Each mode gives a different behaviour: <pre class="fragment">ASYNC - Will configure the event and return immediately.

SYNC_SPINWAIT - will return DEVICE_INVALID_PARAMETER

SYNC_SLEEP - Will configure the event and block the current fiber until the
             event is received.
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DEVICE_INVALID_PARAMETER if the mode given is SYNC_SPINWAIT, otherwise DEVICE_OK.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>delimeters are matched on a per byte basis. </dd></dl>

</div>
</div>
<a id="a87cc6101c0fd5fa14e2cb37b666f214e" name="a87cc6101c0fd5fa14e2cb37b666f214e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87cc6101c0fd5fa14e2cb37b666f214e">&#9670;&nbsp;</a></span>getChar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Serial::getChar </td>
          <td>(</td>
          <td class="paramtype">SerialMode&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Reads a single character from the rxBuff</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>the selected mode, one of: ASYNC, SYNC_SPINWAIT, SYNC_SLEEP. Each mode gives a different behaviour: <pre class="fragment">ASYNC - A character is read from the rxBuff if available, if there
        are no characters to be read, a value of zero is returned immediately.

SYNC_SPINWAIT - A character is read from the rxBuff if available, if there
                are no characters to be read, this method will spin
                (lock up the processor) until a character is available.

SYNC_SLEEP - A character is read from the rxBuff if available, if there
             are no characters to be read, the calling fiber sleeps
             until there is a character available.
</pre> Defaults to SYNC_SLEEP.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a character from the circular buffer, or DEVICE_NO_DATA is there are no characters in the buffer. </dd></dl>

</div>
</div>
<a id="a3602204cffd7992a85fb1564cbbe9e35" name="a3602204cffd7992a85fb1564cbbe9e35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3602204cffd7992a85fb1564cbbe9e35">&#9670;&nbsp;</a></span>getRxBufferSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Serial::getRxBufferSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >The size of our rx buffer in bytes.</p>
<dl class="section return"><dt>Returns</dt><dd>the current size of rxBuff in bytes </dd></dl>

</div>
</div>
<a id="a4e393fde4d19ef2ec8f65db8a8b8b230" name="a4e393fde4d19ef2ec8f65db8a8b8b230"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e393fde4d19ef2ec8f65db8a8b8b230">&#9670;&nbsp;</a></span>getTxBufferSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Serial::getTxBufferSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >The size of our tx buffer in bytes.</p>
<dl class="section return"><dt>Returns</dt><dd>the current size of txBuff in bytes </dd></dl>

</div>
</div>
<a id="a9dacc585b3a25af82e3c701de51c3d79" name="a9dacc585b3a25af82e3c701de51c3d79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dacc585b3a25af82e3c701de51c3d79">&#9670;&nbsp;</a></span>idleCallback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Serial::idleCallback </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Implement this function to receive a callback when the device is idling. </p>

<p>Reimplemented from <a class="el" href="classcodal_1_1_codal_component.html#a37dab3cb4347533746d0e4f557e8feb5">codal::CodalComponent</a>.</p>

</div>
</div>
<a id="a1101d6c554227bcbe9dafbe0910830e0" name="a1101d6c554227bcbe9dafbe0910830e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1101d6c554227bcbe9dafbe0910830e0">&#9670;&nbsp;</a></span>initialiseRx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Serial::initialiseRx </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >We do not want to always have our buffers initialised, especially if users to not use them. We only bring them up on demand. </p>

</div>
</div>
<a id="ab1f53e340ed1ea123af4adfe3880b9bc" name="ab1f53e340ed1ea123af4adfe3880b9bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1f53e340ed1ea123af4adfe3880b9bc">&#9670;&nbsp;</a></span>initialiseTx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Serial::initialiseTx </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >We do not want to always have our buffers initialised, especially if users to not use them. We only bring them up on demand. </p>

</div>
</div>
<a id="a5419572191df40c29ff312623adb7f7f" name="a5419572191df40c29ff312623adb7f7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5419572191df40c29ff312623adb7f7f">&#9670;&nbsp;</a></span>isReadable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Serial::isReadable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Determines whether there is any data waiting in our Rx buffer.</p>
<dl class="section return"><dt>Returns</dt><dd>1 if we have space, 0 if we do not.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>We do not wrap the super's readable() method as we don't want to interfere with communities that use manual calls to serial.readable(). </dd></dl>

</div>
</div>
<a id="a38120bef500231fc0d1c35c096480206" name="a38120bef500231fc0d1c35c096480206"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38120bef500231fc0d1c35c096480206">&#9670;&nbsp;</a></span>isWriteable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Serial::isWriteable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Determines if we have space in our txBuff.</p>
<dl class="section return"><dt>Returns</dt><dd>1 if we have space, 0 if we do not.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>We do not wrap the super's writeable() method as we don't want to interfere with communities that use manual calls to serial.writeable(). </dd></dl>

</div>
</div>
<a id="a64c5b83c82f37e4b287f8630685185d7" name="a64c5b83c82f37e4b287f8630685185d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64c5b83c82f37e4b287f8630685185d7">&#9670;&nbsp;</a></span>lockRx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Serial::lockRx </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Locks the mutex so that others can't use this serial instance for reception </p>

</div>
</div>
<a id="ad89cef8d8e137df558692f126baf9d21" name="ad89cef8d8e137df558692f126baf9d21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad89cef8d8e137df558692f126baf9d21">&#9670;&nbsp;</a></span>lockTx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Serial::lockTx </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Locks the mutex so that others can't use this serial instance for transmission </p>

</div>
</div>
<a id="aeb24acb729f10f75cb6e201f16c86c8e" name="aeb24acb729f10f75cb6e201f16c86c8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb24acb729f10f75cb6e201f16c86c8e">&#9670;&nbsp;</a></span>putc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int codal::Serial::putc </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >SUB CLASSES / IMPLEMENTATIONS DEFINE THE FOLLOWING METHODS: </p>

</div>
</div>
<a id="aef0c7ac915d0033a140d5afac4b584ad" name="aef0c7ac915d0033a140d5afac4b584ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef0c7ac915d0033a140d5afac4b584ad">&#9670;&nbsp;</a></span>read() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcodal_1_1_managed_string.html">ManagedString</a> Serial::read </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SerialMode&#160;</td>
          <td class="paramname"><em>mode</em> = <code>DEVICE_DEFAULT_SERIAL_MODE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Reads multiple characters from the rxBuff and returns them as a <a class="el" href="classcodal_1_1_managed_string.html">ManagedString</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>the number of characters to read.</td></tr>
    <tr><td class="paramname">mode</td><td>the selected mode, one of: ASYNC, SYNC_SPINWAIT, SYNC_SLEEP. Each mode gives a different behaviour: <pre class="fragment">ASYNC - If the desired number of characters are available, this will return
        a ManagedString with the expected size. Otherwise, it will read however
        many characters there are available.

SYNC_SPINWAIT - If the desired number of characters are available, this will return
                a ManagedString with the expected size. Otherwise, this method will spin
                (lock up the processor) until the desired number of characters have been read.

SYNC_SLEEP - If the desired number of characters are available, this will return
             a ManagedString with the expected size. Otherwise, the calling fiber sleeps
             until the desired number of characters have been read.
</pre> Defaults to SYNC_SLEEP.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classcodal_1_1_managed_string.html">ManagedString</a>, or an empty <a class="el" href="classcodal_1_1_managed_string.html">ManagedString</a> if an error was encountered during the read. </dd></dl>

</div>
</div>
<a id="af926923fdece1d7f4c97d9a4ba3f9586" name="af926923fdece1d7f4c97d9a4ba3f9586"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af926923fdece1d7f4c97d9a4ba3f9586">&#9670;&nbsp;</a></span>read() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Serial::read </td>
          <td>(</td>
          <td class="paramtype">SerialMode&#160;</td>
          <td class="paramname"><em>mode</em> = <code>DEVICE_DEFAULT_SERIAL_MODE</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Reads a single character from the rxBuff</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>the selected mode, one of: ASYNC, SYNC_SPINWAIT, SYNC_SLEEP. Each mode gives a different behaviour: <pre class="fragment">ASYNC - A character is read from the rxBuff if available, if there
        are no characters to be read, a value of DEVICE_NO_DATA is returned immediately.

SYNC_SPINWAIT - A character is read from the rxBuff if available, if there
                are no characters to be read, this method will spin
                (lock up the processor) until a character is available.

SYNC_SLEEP - A character is read from the rxBuff if available, if there
             are no characters to be read, the calling fiber sleeps
             until there is a character available.
</pre> Defaults to SYNC_SLEEP.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a character, CODAL_SERIAL_IN_USE if another fiber is using the serial instance for reception, DEVICE_NO_RESOURCES if buffer allocation did not complete successfully, or DEVICE_NO_DATA if the rx buffer is empty and the mode given is ASYNC. </dd></dl>

</div>
</div>
<a id="a81ff3a381aa6d838cc975c2520acb4b1" name="a81ff3a381aa6d838cc975c2520acb4b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81ff3a381aa6d838cc975c2520acb4b1">&#9670;&nbsp;</a></span>read() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Serial::read </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bufferLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SerialMode&#160;</td>
          <td class="paramname"><em>mode</em> = <code>DEVICE_DEFAULT_SERIAL_MODE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Reads multiple characters from the rxBuff and fills a user buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>a pointer to a user allocated buffer.</td></tr>
    <tr><td class="paramname">bufferLen</td><td>the amount of data that can be safely stored</td></tr>
    <tr><td class="paramname">mode</td><td>the selected mode, one of: ASYNC, SYNC_SPINWAIT, SYNC_SLEEP. Each mode gives a different behaviour: <pre class="fragment">ASYNC - If the desired number of characters are available, this will fill
        the given buffer. Otherwise, it will fill the buffer with however
        many characters there are available.

SYNC_SPINWAIT - If the desired number of characters are available, this will fill
                the given buffer. Otherwise, this method will spin (lock up the processor)
                and fill the buffer until the desired number of characters have been read.

SYNC_SLEEP - If the desired number of characters are available, this will fill
             the given buffer. Otherwise, the calling fiber sleeps
             until the desired number of characters have been read.
</pre> Defaults to SYNC_SLEEP.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of characters read, or CODAL_SERIAL_IN_USE if another fiber is using the instance for receiving. </dd></dl>

</div>
</div>
<a id="ab164675b09d4202bd7d73c11d1ac45d6" name="ab164675b09d4202bd7d73c11d1ac45d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab164675b09d4202bd7d73c11d1ac45d6">&#9670;&nbsp;</a></span>readUntil()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcodal_1_1_managed_string.html">ManagedString</a> Serial::readUntil </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcodal_1_1_managed_string.html">ManagedString</a>&#160;</td>
          <td class="paramname"><em>delimeters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SerialMode&#160;</td>
          <td class="paramname"><em>mode</em> = <code>DEVICE_DEFAULT_SERIAL_MODE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Reads until one of the delimeters matches a character in the rxBuff</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">delimeters</td><td>a <a class="el" href="classcodal_1_1_managed_string.html">ManagedString</a> containing a sequence of delimeter characters e.g. <a class="el" href="classcodal_1_1_managed_string.html">ManagedString</a>("\r\n")</td></tr>
    <tr><td class="paramname">mode</td><td>the selected mode, one of: ASYNC, SYNC_SPINWAIT, SYNC_SLEEP. Each mode gives a different behaviour: <pre class="fragment">ASYNC - If one of the delimeters matches a character already in the rxBuff
        this method will return a ManagedString up to the delimeter.
        Otherwise, it will return an Empty ManagedString.

SYNC_SPINWAIT - If one of the delimeters matches a character already in the rxBuff
                this method will return a ManagedString up to the delimeter.
                Otherwise, this method will spin (lock up the processor) until a
                received character matches one of the delimeters.

SYNC_SLEEP - If one of the delimeters matches a character already in the rxBuff
             this method will return a ManagedString up to the delimeter.
             Otherwise, the calling fiber sleeps until a character matching one
             of the delimeters is seen.
</pre> Defaults to SYNC_SLEEP.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classcodal_1_1_managed_string.html">ManagedString</a> containing the characters up to a delimeter, or an Empty <a class="el" href="classcodal_1_1_managed_string.html">ManagedString</a>, if another fiber is currently using this instance for reception.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>delimeters are matched on a per byte basis. </dd></dl>

</div>
</div>
<a id="a395667dae79c223d62adf70fbb175f4c" name="a395667dae79c223d62adf70fbb175f4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a395667dae79c223d62adf70fbb175f4c">&#9670;&nbsp;</a></span>redirect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Serial::redirect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcodal_1_1_pin.html">Pin</a> &amp;&#160;</td>
          <td class="paramname"><em>tx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcodal_1_1_pin.html">Pin</a> &amp;&#160;</td>
          <td class="paramname"><em>rx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >A way of dynamically configuring the serial instance to use pins other than USBTX and USBRX.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tx</td><td>the new transmission pin.</td></tr>
    <tr><td class="paramname">rx</td><td>the new reception pin.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CODAL_SERIAL_IN_USE if another fiber is currently transmitting or receiving, otherwise DEVICE_OK. </dd></dl>

</div>
</div>
<a id="a2453e9d4752e90313032f8777042d044" name="a2453e9d4752e90313032f8777042d044"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2453e9d4752e90313032f8777042d044">&#9670;&nbsp;</a></span>rxBufferedSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Serial::rxBufferedSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >The number of bytes currently stored in our rx buffer waiting to be digested, by the user.</p>
<dl class="section return"><dt>Returns</dt><dd>The currently buffered number of bytes in our rxBuff. </dd></dl>

</div>
</div>
<a id="ab96eb0e1638ffa0189a4f3241bc747e6" name="ab96eb0e1638ffa0189a4f3241bc747e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab96eb0e1638ffa0189a4f3241bc747e6">&#9670;&nbsp;</a></span>rxInUse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Serial::rxInUse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Determines if the serial bus is currently in use by another fiber for reception.</p>
<dl class="section return"><dt>Returns</dt><dd>The state of our mutex lock for reception.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Only one fiber can call read at a time </dd></dl>

</div>
</div>
<a id="a2a5f11ee25b5f74f1585bb665a077860" name="a2a5f11ee25b5f74f1585bb665a077860"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a5f11ee25b5f74f1585bb665a077860">&#9670;&nbsp;</a></span>send() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Serial::send </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcodal_1_1_managed_string.html">ManagedString</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SerialMode&#160;</td>
          <td class="paramname"><em>mode</em> = <code>DEVICE_DEFAULT_SERIAL_MODE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sends a <a class="el" href="classcodal_1_1_managed_string.html">ManagedString</a> over the serial line.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>the string to send</td></tr>
    <tr><td class="paramname">mode</td><td>the selected mode, one of: ASYNC, SYNC_SPINWAIT, SYNC_SLEEP. Each mode gives a different behaviour: <pre class="fragment">ASYNC - bytes are copied into the txBuff and returns immediately.

SYNC_SPINWAIT - bytes are copied into the txBuff and this method
                will spin (lock up the processor) until all bytes
                have been sent.

SYNC_SLEEP - bytes are copied into the txBuff and the fiber sleeps
             until all bytes have been sent. This allows other fibers
             to continue execution.
</pre> Defaults to SYNC_SLEEP.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes written, CODAL_SERIAL_IN_USE if another fiber is using the serial instance for transmission, DEVICE_INVALID_PARAMETER if buffer is invalid, or the given bufferLen is &lt;= 0. </dd></dl>

</div>
</div>
<a id="aa4e3dd55fb0ee1237a760c3bdb8ed89c" name="aa4e3dd55fb0ee1237a760c3bdb8ed89c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4e3dd55fb0ee1237a760c3bdb8ed89c">&#9670;&nbsp;</a></span>send() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Serial::send </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bufferLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SerialMode&#160;</td>
          <td class="paramname"><em>mode</em> = <code>DEVICE_DEFAULT_SERIAL_MODE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sends a buffer of known length over the serial line.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>a pointer to the first character of the buffer</td></tr>
    <tr><td class="paramname">len</td><td>the number of bytes that are safely available to read.</td></tr>
    <tr><td class="paramname">mode</td><td>the selected mode, one of: ASYNC, SYNC_SPINWAIT, SYNC_SLEEP. Each mode gives a different behaviour: <pre class="fragment">ASYNC - bytes are copied into the txBuff and returns immediately.

SYNC_SPINWAIT - bytes are copied into the txBuff and this method
                will spin (lock up the processor) until all bytes
                have been sent.

SYNC_SLEEP - bytes are copied into the txBuff and the fiber sleeps
             until all bytes have been sent. This allows other fibers
             to continue execution.
</pre> Defaults to SYNC_SLEEP.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes written, CODAL_SERIAL_IN_USE if another fiber is using the serial instance for transmission, DEVICE_INVALID_PARAMETER if buffer is invalid, or the given bufferLen is &lt;= 0. </dd></dl>

</div>
</div>
<a id="a0e6939e1a93062bf0ae695a61a630fad" name="a0e6939e1a93062bf0ae695a61a630fad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e6939e1a93062bf0ae695a61a630fad">&#9670;&nbsp;</a></span>sendChar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Serial::sendChar </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SerialMode&#160;</td>
          <td class="paramname"><em>mode</em> = <code>DEVICE_DEFAULT_SERIAL_MODE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sends a single character over the serial line.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>the character to send</td></tr>
    <tr><td class="paramname">mode</td><td>the selected mode, one of: ASYNC, SYNC_SPINWAIT, SYNC_SLEEP. Each mode gives a different behaviour: <pre class="fragment">ASYNC - the character is copied into the txBuff and returns immediately.

SYNC_SPINWAIT - the character is copied into the txBuff and this method
                will spin (lock up the processor) until the character has
                been sent.

SYNC_SLEEP - the character is copied into the txBuff and the fiber sleeps
             until the character has been sent. This allows other fibers
             to continue execution.
</pre> Defaults to SYNC_SLEEP.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes written, or CODAL_SERIAL_IN_USE if another fiber is using the serial instance for transmission. </dd></dl>

</div>
</div>
<a id="a10bd53e8a33492fd80f9e58b8889ebfc" name="a10bd53e8a33492fd80f9e58b8889ebfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10bd53e8a33492fd80f9e58b8889ebfc">&#9670;&nbsp;</a></span>setBaud()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Serial::setBaud </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>baudrate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >A wrapper around the inherited method "baud" so we can trap the baud rate as it changes and restore it if <a class="el" href="classcodal_1_1_serial.html#a395667dae79c223d62adf70fbb175f4c">redirect()</a> is called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baudrate</td><td>the new baudrate. See:<ul>
<li><a href="https://github.com/mbedmicro/mbed/blob/master/libraries/mbed/targets/hal/TARGET_NORDIC/TARGET_MCU_NRF51822/serial_api.c">https://github.com/mbedmicro/mbed/blob/master/libraries/mbed/targets/hal/TARGET_NORDIC/TARGET_MCU_NRF51822/serial_api.c</a> for permitted baud rates.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DEVICE_INVALID_PARAMETER if baud rate is less than 0, otherwise DEVICE_OK.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>the underlying implementation chooses the first allowable rate at or above that requested. </dd></dl>

</div>
</div>
<a id="ad7fb939952a2021fc7144b2c7eea0674" name="ad7fb939952a2021fc7144b2c7eea0674"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7fb939952a2021fc7144b2c7eea0674">&#9670;&nbsp;</a></span>setRxBufferSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Serial::setRxBufferSize </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Reconfigures the size of our rxBuff</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>the new size for our rxBuff</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CODAL_SERIAL_IN_USE if another fiber is currently using this instance for reception, otherwise DEVICE_OK. </dd></dl>

</div>
</div>
<a id="adcf69b11c57d4a0c88f7b9486f3b3f01" name="adcf69b11c57d4a0c88f7b9486f3b3f01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcf69b11c57d4a0c88f7b9486f3b3f01">&#9670;&nbsp;</a></span>setTxBufferSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Serial::setTxBufferSize </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Reconfigures the size of our txBuff</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>the new size for our txBuff</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CODAL_SERIAL_IN_USE if another fiber is currently using this instance for transmission, otherwise DEVICE_OK. </dd></dl>

</div>
</div>
<a id="a30622ea7b68857a4704998cf9acc1f6b" name="a30622ea7b68857a4704998cf9acc1f6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30622ea7b68857a4704998cf9acc1f6b">&#9670;&nbsp;</a></span>txBufferedSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Serial::txBufferedSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >The number of bytes currently stored in our tx buffer waiting to be transmitted by the hardware.</p>
<dl class="section return"><dt>Returns</dt><dd>The currently buffered number of bytes in our txBuff. </dd></dl>

</div>
</div>
<a id="a14bbd54b2e5b986b7bc3b14a830833c3" name="a14bbd54b2e5b986b7bc3b14a830833c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14bbd54b2e5b986b7bc3b14a830833c3">&#9670;&nbsp;</a></span>txInUse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Serial::txInUse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Determines if the serial bus is currently in use by another fiber for transmission.</p>
<dl class="section return"><dt>Returns</dt><dd>The state of our mutex lock for transmition.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Only one fiber can call send at a time </dd></dl>

</div>
</div>
<a id="a5278b596bb36574bc2a7f2c69965e7d0" name="a5278b596bb36574bc2a7f2c69965e7d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5278b596bb36574bc2a7f2c69965e7d0">&#9670;&nbsp;</a></span>unlockRx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Serial::unlockRx </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Unlocks the mutex so that others can use this serial instance for reception </p>

</div>
</div>
<a id="a1d94f3b0d677105de4a3adc332c91f67" name="a1d94f3b0d677105de4a3adc332c91f67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d94f3b0d677105de4a3adc332c91f67">&#9670;&nbsp;</a></span>unlockTx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Serial::unlockTx </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Unlocks the mutex so that others can use this serial instance for transmission </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>New folder/codal-core/inc/driver-models/<a class="el" href="_serial_8h_source.html">Serial.h</a></li>
<li>New folder/codal-core/source/driver-models/Serial.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacecodal.html">codal</a></li><li class="navelem"><a class="el" href="classcodal_1_1_serial.html">Serial</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3 </li>
  </ul>
</div>
</body>
</html>
